\chapter{Implementation}

To allow easy integration into any Android app, the library is implemented
as an Android Library Project \cite{android-library}, which enables it to leverage the 
full functionality of the android platform - it can make use of its own assets and
layouts and manage its own dependencies - while being self contained and portable between 
projects. The only extra considerations that have to be made with this approach is to ensure
that all the project resources (layouts, strings, images etc.) are prefixed to avoid conflict
with the application the library is integrated into.

\section{Integrating the Library}

To specify tasks, the developer creates two json files which are
included in the application's \verb+assets/+ directory. These files specify all the tasks that are available to perform, and what order they will be performed in.

The testing functionality must be easy to remove/disable if the developer
does not want it present in the released version. To know when to begin and end tasks,
inject the library's user interface in the app, and gather data about the participant's 
performance, however, some integration with the application's code is needed.
To keep this to a minimum, all interaction with
the library in performed using the static \verb/Gamify/ class. This allows for
easy removal of the library as the developer can just find all references to
this class within the main application code and remove them. Since most Android
developers use \emph{Proguard} while compiling release versions, the rule below could be
included to automatically strip function calls to the library out of production versions.

\begin{minted}{text}
  -assumenosideeffects class com.example.Gamify {
    <methods>;
  }
\end{minted}

Alternatively, the library can also be disabled by passing \verb|false| when initialising. The
initialisation is done by calling \verb|init| in either the \verb|Application|
or initial \verb|Activity|'s \verb|onCreate| method, passing the two
aforementioned json files.

\begin{minted}{java}
  Gamify.init(this /* Context */, true /* Enabled */,
      "challenges.json", "sequences.json");
\end{minted}

\subsection{Defining tasks}

The ``challenges.json'' and ``sequences.json'' files define the tasks and
challenges that will be used in testing, identified by ids. Each task has a title, description, and optional instruction that appears at the top of the screen during a task, and defaults to the title. The sequences file defines groups of tasks, and which order they will be run in. It also specifies whether to reset the user's position in the application hierarchy after a task, or continue from where they finished the previous task.

\subsection{Integrating Tasks Into the Application}

To start a sequence,the developer can simply call a single method, specifying the ID of the sequence
to be started.

\begin{minted}{java}
  Gamify.startSequence("sequenceid");
\end{minted}

This will bring up the welcome screen and instructions as to how the testing works,
and allow the user to begin the first task in the sequence. Subsequent tasks are
automatically started when the previous one is finished.

Triggering points that will complete tasks are achieved with another method
call. For example if one task was completed by playing a song in the app, then
the corresponding code might look like:

\begin{minted}{java}
  public void playSong(Song song) {
    Gamify.completeChallenge("playsong");

    //... Code to play the song
  }
\end{minted}

If the ``playsong'' task is the current task, then it will be completed,
otherwise the method call will be ignored.

Beyond this, in each \verb|Activity|'s \verb|onResume| and \verb|onPause|
methods, the library must be notified.

\begin{minted}{java}
  @Override protected void onResume() {
     super.onResume();

     Gamify.onActivityResume(this);
  }

  @Override protected void onPause() {
     super.onPause();

     Gamify.onActivityPause(this);
  }
\end{minted}

This is so user interaction can be tracked, and the library's overlays can be
shown above the foreground activity. Since applications are usually designed so
that all activities inherit from a single base activity, this should not add
much extra overhead for the developer. These two methods can optionally be given 
additional arguments as strings, as in the case of the search activity in section
\ref{sec:developer-feedback}.

Finally, any additional navigation points can be tracked manually, by calling

\begin{minted}{java}
  Gamify.trackNavPoint("Navpoint name");
\end{minted}

This is useful for tracking fragment transactions, or anything else the tester
deems relevant.

\section{Developer Interface}

\subsection{Uploading and Storing Data}

Once a task has been completed or abandoned, the data must be collected and centralised.

To do this, the data is converted to a JSON format and automatically uploaded to a server
running a CouchDB database. A map-reduce query in the database ca be used to extract the data
in the form wanted for the graph display.

This approach was chosen for its simplicity, ease of implementation, and the ability to iterate quickly;
as CouchDB is a document oriented database, the raw JSON data can be stored as-is without the need
to define a schema or do any preprocessing. The map-reduce is run incrementally when new documents are 
received, and the results cached, so queries remain fast.

\subsection{Accessing Data}

A javascript application on a web page queries the database and generates the navigation graph for
each task. The query returns all the navigation paths recorded for a particular task, and the application
handles processing backtracks, merging the paths and rendering, using The Dracula Graph library \cite{dracula-graph} to display the final grahps.