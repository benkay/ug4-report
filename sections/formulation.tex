\chapter{Formulation of the Problem \& Proposed Solution}

\section{Current Solutions}

In order to make databases easier to use for everyone we must first work out why they are difficult to use and how current solutions fall short. We see that most current database front-ends are either custom built or ugly general purpose table styled editors that make any meaningful edits hard to comprehend.

\subsection{Bespoke Software}

The custom built solutions usually don't look anything like a database and often on the contrary completely hide the fact that there is a database powering them. Web applications such as Facebook are classic examples of this: behind the scenes there will be databases holding and retrieving information but there will never be a single mention of a select, join, table, or view on the front end for the user to contend with.

There are clear advantages to showing the database in this manner. Assuming that the front end is well designed and accessible, any user will be able to perform all of the required actions on the stored data. This also includes operations that are would be fantastically complex if they needed to be typed out as a couple of huge \ac{SQL} statements surrounded by a transaction. Instead, they are just a button on a web page.

The problem with taking this solution to the database accessibility problem is how specific and bespoke it is. We are unable to generalise this beyond very simple cases due to the varying scales and types of data stored in databases. In addition, these solutions are expensive and time consuming to create each time we have a new schema and data to display and manipulate.

\subsection{General Purpose Software}

The second solution to the problem currently involves displaying the information in the database in its root form of tables, rows and views. This information is then logically displayed in lists and tables in the user interface for manipulation and querying.

The advantages of this kind of interface are clear. A simple interface such as this can display any kind of information that is present inside the database. There is no need to create a new piece of software for each distinct database. This allows costs to be lower and time to be saved when simple modifications need to be made.

However, this solution shows the core ``data structures'' of the database and is therefore not suited for novice users as it requires knowledge of these concepts to use effectively. While this form of interface has the advantage of making simple tasks simple is also has the disadvantage of keeping complex operations complex. Ideally we would want to simplify these operations too.

\section{Proposed Solution}

A good compromise needs to be found between these two extremes: user-friendly but bespoke and hard-to-use but powerful. In order to find this compromise I am going to present the user with a new type of view of the database that they are already familiar with: a file and directory tree.

This representation makes sense from a familiarity perspective as nearly all computer users will have at some point had experience of using a file tree. It additionally makes sense when applied to the structure of a database too. \acf{DBMS} have a shallow tree structure when representing the hierarchy of a server, database, table, and records. A file tree is a simple way of displaying this structure that the user is familiar with.

 A further advantage of using the files and directories representation is that it also allows the user to not just manipulate the files and directories but also modify their contents. This allows us to present the data to the user in a program that they are familiar with such as an office package.